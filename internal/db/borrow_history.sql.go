// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: borrow_history.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBorrowHistory = `-- name: CreateBorrowHistory :one
INSERT INTO borrow_history (book_id, user_id, borrowed_at)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateBorrowHistoryParams struct {
	BookID     int32            `json:"book_id"`
	UserID     int32            `json:"user_id"`
	BorrowedAt pgtype.Timestamp `json:"borrowed_at"`
}

func (q *Queries) CreateBorrowHistory(ctx context.Context, arg CreateBorrowHistoryParams) (int32, error) {
	row := q.db.QueryRow(ctx, createBorrowHistory, arg.BookID, arg.UserID, arg.BorrowedAt)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getActiveBorrowHistory = `-- name: GetActiveBorrowHistory :one
SELECT id, book_id, user_id, borrowed_at, returned_at
FROM borrow_history
WHERE user_id = $1 AND book_id = $2 AND returned_at IS NULL
`

type GetActiveBorrowHistoryParams struct {
	UserID int32 `json:"user_id"`
	BookID int32 `json:"book_id"`
}

func (q *Queries) GetActiveBorrowHistory(ctx context.Context, arg GetActiveBorrowHistoryParams) (BorrowHistory, error) {
	row := q.db.QueryRow(ctx, getActiveBorrowHistory, arg.UserID, arg.BookID)
	var i BorrowHistory
	err := row.Scan(
		&i.ID,
		&i.BookID,
		&i.UserID,
		&i.BorrowedAt,
		&i.ReturnedAt,
	)
	return i, err
}

const isBookBorrowed = `-- name: IsBookBorrowed :one
SELECT EXISTS(
    SELECT 1
    FROM borrow_history
    WHERE book_id = $1 AND returned_at IS NULL
)
`

func (q *Queries) IsBookBorrowed(ctx context.Context, bookID int32) (bool, error) {
	row := q.db.QueryRow(ctx, isBookBorrowed, bookID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listBorrowHistoryByBookID = `-- name: ListBorrowHistoryByBookID :many
SELECT id, book_id, user_id, borrowed_at, returned_at
FROM borrow_history
WHERE book_id = $1
ORDER BY borrowed_at DESC
`

func (q *Queries) ListBorrowHistoryByBookID(ctx context.Context, bookID int32) ([]BorrowHistory, error) {
	rows, err := q.db.Query(ctx, listBorrowHistoryByBookID, bookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BorrowHistory
	for rows.Next() {
		var i BorrowHistory
		if err := rows.Scan(
			&i.ID,
			&i.BookID,
			&i.UserID,
			&i.BorrowedAt,
			&i.ReturnedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBorrowHistoryReturnDate = `-- name: UpdateBorrowHistoryReturnDate :exec
UPDATE borrow_history
SET returned_at = $1
WHERE id = $2
`

type UpdateBorrowHistoryReturnDateParams struct {
	ReturnedAt pgtype.Timestamp `json:"returned_at"`
	ID         int32            `json:"id"`
}

func (q *Queries) UpdateBorrowHistoryReturnDate(ctx context.Context, arg UpdateBorrowHistoryReturnDateParams) error {
	_, err := q.db.Exec(ctx, updateBorrowHistoryReturnDate, arg.ReturnedAt, arg.ID)
	return err
}
